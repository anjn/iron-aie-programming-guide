# Section 2a - Object FIFO基礎

## 核心概念

Object FIFOは、「ソースと1つまたは複数の宛先間のデータ移動接続」を表します。このフレームワークは、設定可能な深さを持つ順序付けバッファリングを可能にし、デフォルトはピンポンバッファリング用の2です。

## 初期化パラメータ

### 高レベルAPI（`ObjectFifo`クラス）

- **`obj_type`**: テンソルのデータ型指定
- **`depth`**: バッファ数（デフォルト: 2）
- **`name`**: コンパイラ参照用の一意識別子
- **`dims_to_stream`**: データ再構成のためのプロデューサアクセスパターン
- **`dims_from_stream_per_cons`**: コンシューマアクセスパターン
- **`plio`**: 専用ポート配線インジケータ

### 低レベルAPI（`object_fifo`クラス）

プロデューサタイルとコンシューマタイルの明示的なタイル配置要件を持つ類似の入力。

## データフローアーキテクチャ

システムは、「1つのプロデューサと1つまたは複数のコンシューマ」というアーキテクチャ制約を強制します。プロデューサとコンシューマは、データフロー用語に従って「アクター」と呼ばれます。高レベル抽象化では、これらは通常、`ObjectFifoHandle`参照にアクセスする`Worker`です。

構造例：

```python
of_in = ObjectFifo(line_type, name="in", depth=3)
my_worker = Worker(core_fn, [of_in.prod(), test_fn])
my_worker = Worker(core_fn2, [of_in.cons(), test_fn2])
```

## アクセスパターン

### 取得と解放のメカニズム

**取得（Acquire）:**

`_acquire()`関数は1つまたは複数のオブジェクトを取得し、`num_elem`パラメータに基づいて単一のオブジェクトまたは配列を返します。フレームワークは順序を維持します。「プロセスが最初にオブジェクトを取得すると、Object FIFOの最初のオブジェクトにアクセスできます。」

**解放（Release）:**

`_release()`関数は、「取得された順序で最も古いものから最も新しいものへ」オブジェクトを返し、部分的な解放が発生した場合にスライディングウィンドウパターンを可能にします。

**重要な動作:**

「前回の取得から解放されていないオブジェクトも、最新の取得呼び出しによって返されます。」連続した取得の間に解放がない場合、同一のオブジェクトが返されます。

## ポート指定

`port`パラメータは`ObjectFifoPort.Produce`と`ObjectFifoPort.Consume`を区別しますが、「プロデューサとコンシューマという用語は、主に論理的な参照を提供する手段として使用されます」。アクセス制限を強制するものではありません。

## 高度な機能

### 可変深さ割り当て

ユーザーは、整数ではなく配列として深さを指定することで、「これらのプールの深さを手動で選択できます」。例：`[2, 3]`は、プロデューサに2つ、コンシューマに3つのリソースを割り当て、デッドロックを防ぎながら並行実行を可能にします。

### 初期化値

オブジェクトは、`initValues`パラメータを介して事前に値を設定でき、データ型仕様に合わせて自動的に再形成されます。

### 同期制御

`disable_synchronization`フラグは、同一プロデューサ-コンシューマ構成などのシナリオで同期オーバーヘッドを削除します。

### メモリ割り当て

`allocate()`関数は、「これらの割り当てに使用される特定のAIEタイルをターゲット」にします。

## DMAインタラクション

すべてのタイルには、「タイルのメモリモジュールからAXIストリーム相互接続へ、またはストリームからメモリモジュールへデータを移動する」責任を持つDMAが含まれています。これにより、同期バッファリングメカニズムを通じて、コアとDMAの並行アクセスが可能になります。

## コンパイラフラグ

- **`dynamic-objFifos`**: 実行中のランタイムオブジェクトカウント追跡のためのMLIR操作を生成
- **`packet-sw-objFifos`**: デフォルトの回路交換アプローチの代わりにパケット交換フローを設定

## プロデューサとコンシューマの関係

Object FIFOでは、データの流れは常に一方向です：

- **プロデューサ**: データを生成してObject FIFOに書き込む
- **コンシューマ**: Object FIFOからデータを読み取って処理する

この明確な役割分担により、データフローが簡潔で理解しやすくなります。

---

**注意**: より詳細な情報と完全なコード例については、[公式ドキュメント](https://github.com/Xilinx/mlir-aie/tree/v1.1.1/programming_guide/section-2/section-2a)を参照してください。
