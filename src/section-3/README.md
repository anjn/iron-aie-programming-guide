# Section 3 - My First Program

このセクションでは、セクション1の構造設計の概念とセクション2のデータ移動の原理を組み合わせて、AIE配列用の最初のプログラムを作成する方法を説明します。

## 概要

このチュートリアルでは、**ベクトルスカラー乗算**（`c = a * factor`）を実演例として使用します。入力ベクトルは合計4096個の32ビット要素で構成され、1024個のチャンクで処理されます。

## バイナリアーティファクト

コンパイルプロセスでは、2つの異なるバイナリが生成されます：

- **デバイスバイナリ**: AIE配列用のXCLBINファイルと命令シーケンス（insts.bin）
- **ホストバイナリ**: AIEバイナリをロードしてテストを管理する実行可能ファイル（test.exe）

## AIE配列の構造記述

### アーキテクチャ

この設計では、2つの主要コンポーネントを配置します：

- **コンピュートコア**: 乗算演算を実行
- **shimDMAユニット**: 入力ベクトルと出力ベクトルのデータ移動を処理

### Object FIFOの実装

3つのObject FIFOがデータフローを管理します：

- `of_in`: 入力ベクトル `a` を転送
- `of_factor`: スカラー乗算係数を転送
- `of_out`: 計算された出力ベクトル `c` を移動

各FIFOは、ShimとCompute Tile DMA間の並行実行を可能にするために深さ2を維持します。

### ランタイム設定

ランタイムシーケンスは、外部メモリとAIE配列間でデータがどのように遷移するかを指定し、同期が必要な転送に明示的な待機条件を設定します。

### コンピュートコアのアクセスパターン

コアはデータオブジェクトを取得し、外部カーネル関数を通じて処理し、ループ構造でそれぞれのFIFOに戻します。

## カーネルコード

この例では、汎用C++コードを使用したスカラープロセッサバージョンを実装します。関数シグネチャは要素ごとにデータを処理します：

```cpp
void vector_scalar_mul_aie_scalar(int32_t *a_in, int32_t *c_out,
                                  int32_t *factor, int32_t N)
```

Object FIFO通信メカニズムのため、スカラー係数は参照解除された配列値として提供されます。

## ホストコードの構造

### 7つの主要セクション:

1. **引数解析**: XCLBINファイルパス、カーネル名、命令シーケンスファイルが必要
2. **命令のロード**: 命令シーケンスをメモリに読み込み
3. **XRT環境**: デバイス通信のためにXRTランタイムを初期化
4. **バッファ作成**: XRTは最大5つのinoutバッファをサポートし、3から始まる連続した`group_id`値を使用してマッピング
5. **データの初期化**: ホストバッファにデータを投入し、デバイスに同期
6. **カーネル実行**: 計算を起動して完了を待機
7. **検証**: デバイスの結果を参照計算と比較

### バッファマッピング規則

`kernel.group_id()`の番号付けは、シーケンス定義の順序に従い、最初の引数がID 3を受け取り、その後インクリメントされます。

## コンパイルと実行

標準的なビルドプロセス：

```bash
make
make run
```

Pythonテストベンチバリアントも利用可能：

```bash
make run_py
```

## 設計のベストプラクティス

ドキュメントでは、設計パラメータをMakefileに一元化して、複数のファイル（構造記述、カーネルソース、ホストコード）全体で一貫性を維持することを推奨しています。これにより、パラメータの不一致によるシステムハングや同期の問題を防ぐことができます。

---

**注意**: より詳細な情報と完全なコード例については、[公式ドキュメント](https://github.com/Xilinx/mlir-aie/tree/v1.1.1/programming_guide/section-3)を参照してください。

-----

[[前へ - Section 2](../section-2/README.md)] [[トップ](../README.md)] [[次へ - Section 4](../section-4/README.md)]
